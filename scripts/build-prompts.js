const fs = require('fs');
const path = require('path');

const rootDir = path.join(__dirname, '..');
const promptsDir = path.join(rootDir, 'prompts');
const outputFile = path.join(rootDir, 'prompts.js');
const manifestFile = path.join(rootDir, 'manifest.json');

function readJSON(filePath) {
  return JSON.parse(fs.readFileSync(filePath, 'utf8'));
}

const preservePunctuation = {
  mindBlowing: [2],
  video: [2],
  image: [2],
};

function stripPunctuation(str) {
  return str.replace(/[.!?]+$/, '');
}

function cleanParts(key, parts) {
  return parts.map((arr, idx) => {
    if (idx < 3 && !(preservePunctuation[key] || []).includes(idx)) {
      return arr.map((s) => stripPunctuation(s));
    }
    return arr;
  });
}

function buildPrompts() {
  const result = {};
  for (const lang of fs.readdirSync(promptsDir)) {
    const langDir = path.join(promptsDir, lang);
    if (!fs.statSync(langDir).isDirectory()) continue;
    result[lang] = {};
    for (const file of fs.readdirSync(langDir)) {
      if (file.endsWith('.json')) {
        const key = path.basename(file, '.json');
        const data = readJSON(path.join(langDir, file));
        if (Array.isArray(data.parts)) {
          data.parts = cleanParts(key, data.parts);
        }
        result[lang][key] = data;
      }
    }
  }
  return result;
}


function bumpManifestVersion() {
  const manifest = readJSON(manifestFile);
  const current = parseInt(manifest.version, 10);
  const next = Number.isNaN(current) ? 1 : current + 1;
  manifest.version = String(next);
  fs.writeFileSync(manifestFile, JSON.stringify(manifest, null, 2) + '\n');
  console.log(`Updated ${manifestFile} to version ${manifest.version}`);
  return manifest.version;
}

function getHtmlFiles(dir) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  let files = [];
  for (const entry of entries) {
    const full = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      if (entry.name === 'node_modules') continue;
      files = files.concat(getHtmlFiles(full));
    } else if (entry.isFile() && entry.name.endsWith('.html')) {
      files.push(full);
    }
  }
  return files;
}

function appendVersionToAssets(html, version) {
  const assetRegex = /(src|href|content)=("|')(?!https?:\/\/|\/\/|mailto:|#)([^"'>]+)(\2)/g;
  const extPattern = /\.(js|css|svg|png|jpe?g|webp|gif|json|ico)$/i;
  let result = html.replace(assetRegex, (m, attr, quote, url) => {
    // Skip anchors to other html pages
    if (url.endsWith('.html')) return m;
    const base = url.split(/[?#]/)[0];
    if (!extPattern.test(base)) return m;
    // Remove existing version query parameter if present
    const cleaned = url.replace(/[?&]v=\d+$/, '');
    const sep = cleaned.includes('?') ? '&' : '?';
    return `${attr}=${quote}${cleaned}${sep}v=${version}${quote}`;
  });
  result = result.replace(/lucide\.min\.js(?:\?v=\d+)?/g, `lucide.min.js?v=${version}`);
  result = result.replace(/prompts\.js(?:\?v=\d+)?/g, `prompts.js?v=${version}`);
  return result;
}

function updateBaseHref(html, href) {
  return html.replace(/<base\s+href="[^"]*"\s*\/?>(?=)/i, `<base href="${href}" />`);
}

function updateHtmlFiles(version, baseHref) {
  const htmlFiles = getHtmlFiles(rootDir);
  for (const file of htmlFiles) {
    const original = fs.readFileSync(file, 'utf8');
    let updated = appendVersionToAssets(original, version);
    if (baseHref) {
      updated = updateBaseHref(updated, baseHref);
    }
    fs.writeFileSync(file, updated);
    console.log(`Updated ${path.relative(rootDir, file)}`);
  }
}

const prompts = buildPrompts();
const output = `// Auto-generated by scripts/build-prompts.js\nwindow.prompts = ${JSON.stringify(
  prompts,
  null,
  2
)};\n`;
fs.writeFileSync(outputFile, output);
console.log(`Wrote ${outputFile}`);

const version = bumpManifestVersion();
const baseHref = process.env.BASE_HREF;
updateHtmlFiles(version, baseHref);
